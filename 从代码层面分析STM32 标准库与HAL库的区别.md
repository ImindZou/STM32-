# 从代码层面分析STM32 标准库与HAL库的区别

![img](https://zdh934.oss-cn-shenzhen.aliyuncs.com/PigGo/202309262036459.gif)

**起因：**今天去上了STM32的开发课程，因为早上起来人比较迷糊，没什么状态，再加上自己本身对代码的理解逻辑能力比较差一点，因此经过内心重重挣扎也是打算写下这篇文章记录一下心路历程，一是总结一下自己学了这么久的一些经验，二是自己想要培养一个及时复盘的良好习惯。

古人云：温故知新，可为师矣。今天也来考一下古。🤣🤣🤣

这篇文章的灵感也是来自于，晚上吃饭时无意中再某DN翻到的一篇文章，给了我灵感，所以打算借鉴作者的文章，按照作者的套路，“抄袭一下✌️”。

[https://blog.csdn.net/qq_20222919/article/details/126767429?utm_source=miniapp_weixin]: 

用过STM32的朋友应该比较清楚，常见的STM32开发有三种方式，寄存器版、标准库版、HAL库版/选用后两者的比较多，但是选用哪一种方式进行开发比较好呢？

> 这让我想起了一句话，生存还是死亡，这是个问题。——To live,to died that is a question.

现在是公说公有理，婆说婆有理，每个人都有每个人的看法，今天不探讨这两种方式的优缺点，只是单纯从代码角度出发，去分析这两种方式写代码的相同点与之间的差异。

**为了更具有对比性，选择了功能差不多的两个程序(LED翻转)**，也是我写过的作业之一，之前就一直在比较它们的源代码，想了想有想法还是发出来比较好，跟网友讨论有反馈还可以互相学习。

看到这个大家都应该比较熟悉了，下面从代码上做出比较：

![image-20230926211641749](https://zdh934.oss-cn-shenzhen.aliyuncs.com/PigGo/202309262116909.png)

左边HAL库，右边标注库，直接对比一下端口设置的函数，可以看出HAL库对端口进行翻转时，调用的是同一个函数，只是参数不一样。下面对比一下端口设置函数。

![image-20230926212301710](https://zdh934.oss-cn-shenzhen.aliyuncs.com/PigGo/202309262123773.png)

两个函数本质上还是操作寄存器，只不过HAL库操作的只是BSRR寄存器，二标准库端口置位时操作的时BSRR寄存器，而复位时操作的时BRR寄存器。我们可以去看一下手册儿，了解一下他们之间的区别。

![image-20230926213024276](https://zdh934.oss-cn-shenzhen.aliyuncs.com/PigGo/202309262130344.png)

通过官方的手册儿可以看出，BRR寄存器相当于BSRR寄存器的高16位，给BSRR高16位写1就是复位端口，给BSRR低16位写1就是置位对应的端口，这是HAL库的写法，而标准库的复位跟置为则在BSRR与BRR之间反复横跳。💃💃💃

![image-20230926213537994](https://zdh934.oss-cn-shenzhen.aliyuncs.com/PigGo/202309262135050.png)

在HAL库中可以看到，当传入的参数是GPIO_PIN_RESET 时，就左移16位，从低位到高位，完成了置为的操作，从而实现I/O的翻转。

从上面这些对比可以看出，HAL库跟标准库都是基于寄存器来实现I/O的翻转的，唯一的区别就是HAL库将标准库的两个函数合二为一了，标准库是参数不变，而调用的函数名发生了变化。

接下来对比LED端口的初始化。

![image-20230926214336760](https://zdh934.oss-cn-shenzhen.aliyuncs.com/PigGo/202309262143811.png)

可以看到端口时钟的使能函数不一样了，HAL库是通过两个独立的函数u来实现，没有参数，标准库是通过一个函数传入参数来实现的，下来进一步查看原函数的区别。

![image-20230926214628447](https://zdh934.oss-cn-shenzhen.aliyuncs.com/PigGo/202309262146506.png)

HAL库将一段代码通过宏定义的方式封装成了一个函数，每个端口的时钟都独立的定义了一个名称，标准库是一个独立函数，通过参数传递的方式来设置每个时钟端口。但它们操作的依然都是APB2ENR寄存器。

接下来看看GPIO口的初始化函数。

![image-20230926215057697](https://zdh934.oss-cn-shenzhen.aliyuncs.com/PigGo/202309262150765.png)

两个函数入口参数是一样的：

![image-20230926215505266](https://zdh934.oss-cn-shenzhen.aliyuncs.com/PigGo/202309262155324.png)

将内部具体实现代码折叠起来可以看到，HAL库里边是一个while循环，配置了端口的所有属性。而标准库里边是三个if语句，分别设置了引脚模式，端口的低16位，高16位。HAL库中的代码比标准库多了很多行。

![image-20230926220227885](https://zdh934.oss-cn-shenzhen.aliyuncs.com/PigGo/202309262202945.png)

标准库设置端口的时候，是在if语句中判断后直接设置的，而HAL端口模式设置时，却使用了switch语句去设置，说明在HAL库中，端口模式合标准库中发送了改变，下面直接查看端口模式具体都有哪些。

![image-20230926220612243](https://zdh934.oss-cn-shenzhen.aliyuncs.com/PigGo/202309262206317.png)

HAL库模式中，不仅包含了标准库中的所有端口模式，同时还多了几种模式。通过名字可以判断是外部事件跟外部中断模式。这些在标准库中都是一个独立的模块，在HAL库中直接跟GPIO模式耦合到一起了，虽然本来配置也要通过GPIO进行配置。体现了一个方便。

![image-20230926221606352](https://zdh934.oss-cn-shenzhen.aliyuncs.com/PigGo/202309262216470.png)

通过代码可以看出HAL库端口的中断模式和事件模式这块是空的，说明这个型号的单片机没有这种模式，也许其他型号就有了。继续往下看，会发现HAL在初始化GPIO的时候顺便把IO的中断模式也配置了。而在标准库中，对中断函数的设置则是要单独在启动文件通过汇编语句进行单独配置的，

![image-20230926221841371](https://zdh934.oss-cn-shenzhen.aliyuncs.com/PigGo/202309262218466.png)

![image-20230926222059576](https://zdh934.oss-cn-shenzhen.aliyuncs.com/PigGo/202309262220642.png)

说明HAL库将关于I/O的所有属性都统一放到一个函数中集中处理了。既然提到了中断，那么再看看中断的配置，HAL库合标准库有什么区别？

![image-20230926222623866](https://zdh934.oss-cn-shenzhen.aliyuncs.com/PigGo/202309262226914.png)

功能函数总览：

![image-20230926223053173](https://zdh934.oss-cn-shenzhen.aliyuncs.com/PigGo/202309262230224.png)

中断初始化配置，其次中断还要配置NVIC，主要是使能中断通道，其他的一通配置下来就可以打通中断了。

![image-20230926224849016](https://zdh934.oss-cn-shenzhen.aliyuncs.com/PigGo/202309262248127.png)

上面主要试讲标准库的中断配置，下面开始讲HAL库中断配置：
![image-20230926225040803](https://zdh934.oss-cn-shenzhen.aliyuncs.com/PigGo/202309262250844.png)

可以看到HAL库中对中断的设置代码比较少，标准库中对终端的设置代码比较多，同时还发现在HAL库中I/O的设置中断时，直接在GPIO的属性里边是设置就可以了。但在标准库中初始化就首先初始化对应端口，端口设置为输入模式，然后调用EXIT_INIT()函数，对中断进行初始化，最后调用NVIC_INIT()函数，分别设置每个中断优先级。相当于每个设置都是独立的函数。而在HAL库是将中断的设置直接集成在GPIO设置函数中，同时设置中断源和中断优先级设置，哦都是通过调用函数，传递参数的方式进行设置的。代码写起来比较少。

![image-20230926232427931](https://zdh934.oss-cn-shenzhen.aliyuncs.com/PigGo/202309262324068.png)

![image-20230926233510486](https://zdh934.oss-cn-shenzhen.aliyuncs.com/PigGo/202309262335627.png)

最后看一下对中断函数的处理，标准库是在中断函数中直接处理带啊吗，而HAL库在中断函数中又调用了公用的中断处理函数，在公用的处理函数中统一处理中断程序。

通过上面这些分析可以看出，标准库函数是对寄存器简单的进行了一次封装。将每个功能都独立地封装并合并在了一起。功能比较单一。而HAL库相当于对寄存器进行了二次或三次封装，它将能合并的功能都合并在了一起。减少了写代码的难度。但是库函数本身阅读起来要比标准库要费劲一些。这样据导致，如果程序出错的话调试起来要比标准库要困难一点。但是HAL库写程序却比较简单，函数的名字也容易理解。更接近于慢性对象思想。

通过对比可以看出，没有那种方式更好，每种都有自己的优缺点，根据实际情况进行开发才是最优解。通过对官方两种库的对比，可以看出在产品开发中代码永远都有优化和改进的空间。以后自己在开发项目的时候，也可以用这两种不同的方式对自己的代码进行优化升级。

![img](https://zdh934.oss-cn-shenzhen.aliyuncs.com/PigGo/202309262346325.gif)