# AT89C51汇编学习

## 点灯

![image-20231104003737242](https://zdh934.oss-cn-shenzhen.aliyuncs.com/PigGo/202311040037455.png)



## 概念说明：

**指令周期：**CPU执行一条指令所需要的时间称为指令周期，它是以极其周期为单位得，指令不同，所需的极其周期也不同。

**时钟周期：**也称为振荡周期，一个时钟周期 = 晶振得倒数。

AT89C51单片机得一个极其周期 = 6个状态周期 = 12个时钟周期。

**AT89C51单片机得指令有单字节、双字节和三字节的，**（这点在Cortex - M3权威指南看到过，今天也是见识到了），它们的指令周期不尽相同，一个单周期指令包含一个机器周期，即12个时钟周期，所以一条单周期指令被执行所占用的时间为12*（1/12000000） = 1us。（准确来来说AT89C51大多都是装的11.0592的晶振，相对会有一些误差）。

> MOV 是单周期指令；DJNZ是双周期指令；一个周期指令1US。

## 程序分析：

```ABAP
（1*200） ————》》（1*125）
```

![image-20231104005915374](https://zdh934.oss-cn-shenzhen.aliyuncs.com/PigGo/202311040059459.png)

![image-20231104012106009](https://zdh934.oss-cn-shenzhen.aliyuncs.com/PigGo/202311040121079.png)

![image-20231104012805443](https://zdh934.oss-cn-shenzhen.aliyuncs.com/PigGo/202311040128520.png)

## DJNZ指令

> 减一不为零转移指令（dec 1 jump if not zero）。DJNZ指令有两种格式：

- DJNZ Rn，rel和DJNZ direct，rel。
    - 前者为双字节指令，其中第二个字节存储rel的相对地址，范围是-128~127，所以转移范围很窄，所以转移的位置为指令的当前PC值加上rel；
    - 第二条指令的第三个字节也是存储rel的，和第一条指令的转移方式相同，都是PC+rel

1. **DJNZ RN，REL** 是一个条件转移指令，先将工作寄存器Rn中的数减“1”
2. 判断结果是否为“0”，不为“0”程序就跳转到行标为REL的地方执行，否则，为“0”就不转移，继续执行下一条指令
3. 需要注意的是，每执行一次DJNZ指令时，工作IC其中的数都会减去1后，在判断是否返回。例如，如果Rn中原来是2，则执行两次**DJNZ**后，Rn中就是0了，**DJNZ**运行的机器周期为2.

## JNZ指令

> JNZ（或JNE）（jump if not zero，or not equal）；不为零或不相等则转移动

- 汇编语言中的条件转移指令。结果不为零（或不相等）则转移
- 格式JNZ（或JNE）PRO

![image-20231104014839396](https://zdh934.oss-cn-shenzhen.aliyuncs.com/PigGo/202311040148464.png)

## 51单片机内的寄存器是R0~R7

> R0~R7在数据存储器里的实际地址是由特殊功能寄存器PSW里的RS1、RS0决定的。

- using 0 时设置RS1 = 0，RS0 = 0，用第0组寄存器，R0~R7的在数据存储区里的实际地址是00H~07H。R0（00H）。。。R7（07H）。
- using 1 时设置RS1 = 0，Rs0 = 1，用第1组寄存器，R0~R7的在数据存储区里的实际地址是08H~0FH。R0（08H）。。。R7（0FH）。
- using 1 时设置RS1 = 1，Rs0 = 0，用第2组寄存器，R0~R7的在数据存储区里的实际地址是08H~0FH。R0（10H）。。。R7（17H）。
- using 1 时设置RS1 = 1，Rs0 = 1，用第3组寄存器，R0~R7的在数据存储区里的实际地址是00H~07H。R0（18H）。。。R7（1FH）。

> 关于51的PSW寄存器，以后学到再讲

1.简介
PSW是一个8位寄存器。PSW的全称是Program Status Word，即程序状态字。

其各位的含义如下：

| PWS位地址      | D7   | D6   | D5   | D4   | D3   | D2   | D1   | D0   |
| :------------- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- |
| ***\*含义\**** | CY   | AC   | F0   | RS1  | RS0  | OV   | -    | P    |

下面分别对各位简单总结：

2.进位标志位（CY）
CY的全称是Carry，有的资料就简写为一个C字母。

在使用加减乘除、左移或右移之类等操作时，这个标志位会受到影响。
因为51单片机一般是对8位数据的操作，当数据的最高位（D7）进行例如加法操作产生进位时，CY就会置1。否则CY等于0；当进行8为减法时，若运算结果有借位，则CY=1，否则C=0。

我把CY这个标志位理解为8位运算中的第九个数据位。

3.辅助进位标志位（AC）
AC的全称是Assistant Carry。

首先说明一下什么是低半字节和高半字节：一个字节有8位，低半字节就是第0位到第3位，高半字节就是第4位到第7位
还是进行8位加法运算，如果低半字节的最高位（D3）有进位，则AC=1，否则AC=0；当进行8位减法运算时，如果D3有借位，则AC=1，否则AC=0、

这个可以和CY标志位进行类比理解。

4.软件标志（F0）
这是用户定义的一个状态标志。可以通过软件对它置位或清零。

5.工作寄存器组选择位RS1和RS0
可以在编程的时候置位或清零，以选择4个工作寄存器组中的一个进行工作。
一个寄存器组有8字节，有四组寄存器，一共32字节。在片内数据存储区中的00H~1FH。

6.溢出标志（OV）
OV的全称是Overflow。
当进行有符号（signed）数加减法运算时，由硬件自动置位或清零。
当OV=1时，表示一个数字已经超出了累加器以补码形式表示一个有符号数的范围，即超出了-128~+127的范围。

在8位补码中，D7一般用来表示符号位，D6~D0用来表示二进制数字。
所以，在加法时，如果最高位（D7）和次高位（D6）中有一个进位，或在减法时两个中有一个借位，OV将被置位。

执行乘法指令（MUL  AB）也会影响OV标志位，当乘积大于255时，OV=1，否则OV=0。
执行除法指令时也会影响OV标志位。

6.1与AC标志位对比
要注意，溢出和进位是两个不同的概念，进位是指无符号数运算时ACC中D7向更高位的进位。溢出是指带符号数补码运算时，运算结果超出8位二进制补码的表示范围。
另外，OV的状态可以由ACC的D7和D6相异或得出。

7.奇偶标志位P
每执行一条汇编指令，单片机都能根据A中1的个数的奇偶自动令P置位或清零，奇为1，偶为0。
此标志位对串行通信的数据传输非常有用，通过就校验可以检验传输的可靠性。
————————————————
原文链接：https://blog.csdn.net/yannanxiu/article/details/17225927

```asm
ORG 00H
START:
	MOV A,#00H
	MOV B,#0FFH
	;CLR P2	;复位
	MOV P2,A
	CALL DELAY
	;SETB P2	;置位
	MOV P2,B
	CALL DELAY
	JMP START		;跳到了START:形成闭环
DELAY:	MOV R5,#25
DELAY1: MOV R6,#100
DELAY2: MOV R7,#100
	DJNZ R7,$
	DJNZ R6,DELAY2		;减1不为0转移到REL标号格式为（DJNZ RN,REL）
	DJNZ R5,DELAY1
	RET
	END
```

![tutieshi_640x1137_2s](https://zdh934.oss-cn-shenzhen.aliyuncs.com/PigGo/202311040207512.gif)



























